#Se descarga la biblioteca Spacy
!python -m spacy download es_core_news_sm # Se reincia el entorno de ejecución

#Se carga la librería
import spacy
nlp = spacy.load('es_core_news_sm')

#Se intalan los distintos paquetes que se van a utilizar
import sys
if 'google.colab' in sys.modules:
    !pip install emoji --upgrade
    !pip install pandas-profiling==2.*
    !pip install plotly==4.*
    !python -m spacy download es_core_news_sm
    !pip install pyldavis
    !pip install gensim
    !pip install nltk
    !pip install chart_studio
    !pip install --upgrade autopep8
    !pip install vaderSentiment
    !pip install datatable
    !pip install unidecode 
    !pip install --upgrade pip
    !pip install -U numpy #Volver a reiniciar el entorno de ejecución
    
#Se cargan las librerias
#Base and Cleaning 
import json
import requests
import pandas as pd
import numpy as np
import emoji
import regex
import re
import string
import pandas as pd
from collections import Counter
from random import seed
from unidecode import unidecode

#Visualizations
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt 
import pyLDAvis
import chart_studio
import chart_studio.plotly as py 
import chart_studio.tools as tls
import matplotlib.pyplot as plt
import pyLDAvis.gensim_models as gensimvis

#Natural Language Processing (NLP)
import spacy
import gensim
from spacy.tokenizer import Tokenizer
from gensim.corpora import Dictionary
from gensim.models.ldamulticore import LdaMulticore
from gensim import models
from gensim.models.coherencemodel import CoherenceModel
from gensim.parsing.preprocessing import STOPWORDS as SW
from sklearn.decomposition import LatentDirichletAllocation, TruncatedSVD
from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer
from sklearn.model_selection import GridSearchCV
from pprint import pprint
from wordcloud import WordCloud, STOPWORDS
stopwords = set(STOPWORDS)
import nltk 
from nltk.tokenize import word_tokenize
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer 
nltk.download('stopwords')
from nltk.corpus import stopwords

#Pre-procesado de datos

#Se cargan los datos obtenidos en R
df_analisis = pd.read_csv('df_filtered_xenofobia.csv',sep=';')

#Se seleccionan aquellos en español
df_analisis = df_analisis[df_analisis['lang'] =="es"]

#Se quitan las stopwords
stop_words=stopwords.words('spanish')
print(stop_words)

#Se quitan aquellas stopwords que no se hayan eliminado en el proceso anterior
stop_words.extend(['y','des','ayyyy','etc','jo'])

#realizamos el proceso de lematización y añadimos de forma manual aquellas que no se hayan realizado
nlp = spacy.load('es_core_news_sm')
def lemma_words(text):
    lemmas = []
    doc= nlp(text)
    for token in doc: 
        if ((token.is_stop == False) and (token.is_punct == False)) and (token.pos_ != 'PRON'):
            lemmas.append(token.lemma_)
    lemmas= [i for i in lemmas if len(i) > 1]
    lemmas = [word for line in lemmas for word in line.split()]
    lemmas=[word for word in lemmas if word not in stop_words]
    lemmas=' '.join(lemmas)
    lemmas=unidecode(lemmas, "utf-8")
    lemmas=re.sub(r"\bllegado\b", "llegar", lemmas)
    lemmas=re.sub(r"\bdigais\b", "decir", lemmas)
    lemmas=re.sub(r"\bmigrant\b", "migrante", lemmas)
    lemmas=re.sub(r"\bespaa\b", "españa", lemmas)
    lemmas=re.sub(r"\bmigrant\b", "migrante", lemmas)
    lemmas=re.sub(r"\barabir\b", "arabe", lemmas)
    lemmas=re.sub(r"\bespaol\b", "español", lemmas)
    lemmas=re.sub(r"\balienigen\b", "alienigena", lemmas)
    lemmas=re.sub(r"\bpatero\b", "patera", lemmas)
    lemmas=re.sub(r"\bruso\b", "rusia", lemmas)
    lemmas=re.sub(r"\balmerio\b", "almeria", lemmas)
    lemmas=re.sub(r"\bbiografie\b", "biografia", lemmas)
    lemmas=re.sub(r"\bdio\b", "dios", lemmas)
    lemmas=re.sub(r"\bingl\b", "ingles", lemmas)
    lemmas=re.sub(r"\baparecero\b", "aparecer", lemmas)
    lemmas=re.sub(r"\bhebreir\b", "hebreo", lemmas)
    lemmas=re.sub(r"\barabar\b", "arabe", lemmas)
    lemmas=re.sub(r"\bquemado\b", "quemar", lemmas)
    lemmas=re.sub(r"\btoma\b", "tomas", lemmas)
    lemmas=re.sub(r"\bnios\b", "niños", lemmas)
    lemmas=re.sub(r"\bpai\b", "pais", lemmas)
    lemmas=re.sub(r"\bgracia\b", "gracias", lemmas)
    lemmas=re.sub(r"\bmarrueco\b", "marruecos", lemmas)
    lemmas=re.sub(r"\bisleto\b", "isleta", lemmas)
    lemmas=re.sub(r"\bnio\b", "niño", lemmas)
    lemmas=re.sub(r"\bcambio\b", "cambiar", lemmas)
    lemmas=re.sub(r"\bexpon\b", "exponer", lemmas)
    lemmas=re.sub(r"\bcompro\b", "comprar", lemmas)
    lemmas=re.sub(r"\bnurio\b", "nuria", lemmas)
    lemmas=re.sub(r"\btraido\b", "traer", lemmas)
    lemmas=re.sub(r"\bnecesitario\b", "necesitar", lemmas)
    lemmas=re.sub(r"\bspacio\b", "espacio", lemmas)
    lemmas=re.sub(r"\bexisten\b", "existir", lemmas)
    lemmas=re.sub(r"\borquestado\b", "orquestar", lemmas)
    lemmas=re.sub(r"\bbeneficiado\b", "beneficiar", lemmas)
    lemmas=re.sub(r"\bmen\b", "mena", lemmas)
    lemmas=re.sub(r"\bderechos\b", "derecho", lemmas)
    lemmas=re.sub(r"\bxenofobio\b", "xenofobia", lemmas)
    lemmas=re.sub(r"\bsharaui\b", "sahara", lemmas)
    lemmas=re.sub(r"\bquemao\b", "quemar", lemmas)
    lemmas=re.sub(r"\bacompaar\b", "acompañar", lemmas)
    lemmas=re.sub(r"\bacompaado\b", "acompañar", lemmas)
    lemmas=re.sub(r"\bucraniano\b", "ucrania", lemmas)
    lemmas=re.sub(r"\bao\b", "año", lemmas)
    lemmas=re.sub(r"\baos\b", "año", lemmas)
    lemmas=re.sub(r"\binvestigacion\b", "investigar", lemmas)
    lemmas = lemmas.split()
    lemmas=[word for word in lemmas if word not in stop_words]
    lemmas=' '.join(lemmas)
    return lemmas


df_analisis['lemmas'] = df_analisis['cleaned_text'].apply(lemma_words)
    
#Eliminamos las celdas vacias y los lemas duplicados
df_analisis.dropna(inplace=True)
df_analisis = df_analisis.drop_duplicates(subset='lemmas', keep="first")
df_analisis

#Generamos el csv de la columna lemas y el completo
df_analisis['lemmas'].to_csv('Lemmas_racismo_v9.csv')
df_analisis.to_csv('Racismo_limpio_v9.csv')

#Creación del Wordcloud

#Se define la función de crear una gráfica de wordcloud y se establecen las características
def plot_cloud(wordcloud):
    plt.figure(figsize=(10, 7))
    plt.imshow(wordcloud) 
    plt.axis("off");
    
#Pintamos el wordcloud
wordcloud = WordCloud(width = 3000, height = 2000, random_state=1, max_words=100, background_color='black', colormap='Set3', collocations=False, stopwords = STOPWORDS).generate(' '.join(df_analisis['lemmas']))
plot_cloud(wordcloud) 

#Análisis Descriptivo de N-Gramas

#Leemos el csv con los datos limpios y filtramos por la columna "Lemas"
df_analisis = pd.read_csv('Racismo_limpio_v9.csv')
dft= df_analisis['lemmas']
dft = [x for x in dft if str(x) != 'nan']
print(dft)

#Se calculan el Valor de TF-IDF de los unigramas
tfIdfVectorizer=TfidfVectorizer(use_idf=True, ngram_range=(1,1))
tfIdf = tfIdfVectorizer.fit_transform(dft)
names=tfIdfVectorizer.get_feature_names_out()
freqs = tfIdf.sum(axis=0).A1
result= dict(zip(names, freqs))
print(result)

# Se enseñan los 30 unigramas con mayor valor TF-IDF
from operator import itemgetter
i = 0
results_sorted=sorted(result.items(), key = itemgetter(1), reverse = True)
for key, value in results_sorted:
    i += 1
    if i == 31:
      break
    print(key, value)

#Se pintan los 30 unigramas con más TF-IDF
df_results=pd.DataFrame.from_dict(results_sorted).head(30)
plt.rcParams.update({'font.size': 20})
plt.figure(figsize=(15,7))
plt.bar(df_results[0],df_results[1])
plt.xticks(rotation=90)
plt.ylabel('TF-IDF Score')
plt.title('Unigramas más relevantes del corpus')

#Se realiza lo mismo con bigramas y trigramas

#Bigramas
tfIdfVectorizer_bi=TfidfVectorizer(use_idf=True, ngram_range=(2,2))
tfIdf_bi = tfIdfVectorizer_bi.fit_transform(dft)
names_bi=tfIdfVectorizer_bi.get_feature_names_out()
freqs_bi = tfIdf_bi.sum(axis=0).A1
result_bi= dict(zip(names_bi, freqs_bi))

from operator import itemgetter
i = 0
results_sorted=sorted(result_bi.items(), key = itemgetter(1), reverse = True)
for key, value in results_sorted:
    i += 1
    if i == 31:
      break
    print(key, value)
    
results_sorted_bi=sorted(result_bi.items(), key = itemgetter(1), reverse = True)
df_results_bi=pd.DataFrame.from_dict(results_sorted_bi).head(30)
plt.rcParams.update({'font.size': 20})
plt.figure(figsize=(15,7))
plt.bar(df_results_bi[0],df_results_bi[1])
plt.xticks(rotation=90)
plt.ylabel('TF-IDF Score')
plt.title('Bigramas más relevantes del corpus')

#Trigramas

tfIdfVectorizer_tri=TfidfVectorizer(use_idf=True, ngram_range=(3,3))
tfIdf_tri = tfIdfVectorizer_tri.fit_transform(dft)
names_tri= tfIdfVectorizer_tri.get_feature_names_out()
freqs_tri = tfIdf_tri.sum(axis=0).A1
result_tri = dict(zip(names_tri, freqs_tri))

from operator import itemgetter
i = 0
results_sorted=sorted(result_tri.items(), key = itemgetter(1), reverse = True)
for key, value in results_sorted:
    i += 1
    if i == 31:
      break
    print(key, value)
    
results_sorted_tri=sorted(result_tri.items(), key = itemgetter(1), reverse = True)
df_results_tri=pd.DataFrame.from_dict(results_sorted_tri).head(30)
plt.rcParams.update({'font.size': 20})
plt.figure(figsize=(15,7))
plt.bar(df_results_tri[0],df_results_tri[1])
plt.xticks(rotation=90)
plt.ylabel('TF-IDF Score')
plt.title('Trigramas más relevantes del corpus')

#Modelado de Tópicos







